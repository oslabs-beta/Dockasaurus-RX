import type { Toast } from './toast';
import type { Dialog } from './dialog';
import type { HttpService } from './http-service';
import type { Exec } from './exec';
import type { NavigationIntents } from './navigation-intents';
/**
 * @since 0.2.0
 */
export interface Extension {
    readonly vm?: ExtensionVM;
    readonly host?: ExtensionHost;
    /**
     * @since 0.3.3
     */
    readonly image: string;
}
/**
 * @since 0.2.0
 */
export interface DesktopUI {
    readonly toast: Toast;
    readonly dialog: Dialog;
    readonly navigate: NavigationIntents;
}
/**
 * @since 0.2.0
 */
export interface ExtensionVM {
    /**
     * Executes a command in the backend container.
     *
     * Example: Execute the command `ls -l` inside the **backend container**:
     *
     * ```typescript
     * await ddClient.extension.vm.cli.exec(
     *   "ls",
     *   ["-l"]
     * );
     *```
     *
     * Streams the output of the command executed in the backend container.
     *
     * When the extension defines its own `docker-compose.yaml` file
     * with multiple containers, the command is executed on the first container defined.
     * Change the order in which containers are defined to execute commands on another
     * container.
     *
     * Example: Spawn the command `ls -l` inside the **backend container**:
     *
     *```typescript
     * await ddClient.extension.vm.cli.exec("ls", ["-l"], {
     *            stream: {
     *              onOutput(data): void {
     *                  // As we can receive both `stdout` and `stderr`, we wrap them in a JSON object
     *                  JSON.stringify(
     *                    {
     *                      stdout: data.stdout,
     *                      stderr: data.stderr,
     *                    },
     *                    null,
     *                    "  "
     *                  );
     *              },
     *              onError(error: any): void {
     *                console.error(error);
     *              },
     *              onClose(exitCode: number): void {
     *                console.log("onClose with exit code " + exitCode);
     *              },
     *            },
     *          });
     *```
     *
     * @param cmd Command to execute.
     * @param args Arguments of the command to execute.
     * @param callback The callback function where to listen from the command output data and errors.
     */
    readonly cli: ExtensionCli;
    readonly service?: HttpService;
}
/**
 * @since 0.2.0
 */
export interface ExtensionHost {
    /**
     * Executes a command in the host.
     *
     * For example, execute the shipped binary `kubectl -h` command in the **host**:
     *
     * ```typescript
     * await ddClient.extension.host.cli.exec("kubectl", ["-h"]);
     * ```
     *
     * ---
     *
     * Streams the output of the command executed in the backend container or in the host.
     *
     * Provided the `kubectl` binary is shipped as part of your extension, you can spawn the `kubectl -h` command in the **host**:
     *
     *```typescript
     * await ddClient.extension.host.cli.exec("kubectl", ["-h"], {
     *            stream: {
     *              onOutput(data): void {
     *                  // As we can receive both `stdout` and `stderr`, we wrap them in a JSON object
     *                  JSON.stringify(
     *                    {
     *                      stdout: data.stdout,
     *                      stderr: data.stderr,
     *                    },
     *                    null,
     *                    "  "
     *                  );
     *              },
     *              onError(error: any): void {
     *                console.error(error);
     *              },
     *              onClose(exitCode: number): void {
     *                console.log("onClose with exit code " + exitCode);
     *              },
     *            },
     *          });
     *```
     */
    readonly cli: ExtensionCli;
}
/**
 * @since 0.2.0
 */
export interface ExtensionCli {
    exec: Exec;
}
